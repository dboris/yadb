/* OS dependent file operation
   super fast fs for small ydb
   fill in a big buffer,
   and write to disk when free()
*/

var fs = require('fs');
var DT = require('./yadb3').datatypes;

var Create = function (path, opts) {

  var handle = null;
  opts = opts || {};
  opts.size = opts.size || 65536 * 2048;
  console.log('ydb estimate size:', opts.size);
  var dbuf = new Buffer(opts.size);
  var cur = 0; //dbuf cursor

  var writeSignature = function (value, pos) {
    dbuf.write(value, pos, value.length, 'utf8');
    if (pos + value.length > cur) cur = pos + value.length;
    return value.length;
  }

  var writeOffset = function (value, pos) {
    dbuf.writeUInt8(Math.floor(value / (65536 * 65536)), pos);
    dbuf.writeUInt32BE(value & 0xFFFFFFFF, pos + 1);
    if (pos + 5 > cur) cur = pos + 5;
    return 5;
  }

  var writeString = function (value, pos, encoding) {
    encoding = encoding || 'ucs2';

    if (encoding === 'utf8') dbuf.write(DT.utf8, pos, 1, 'utf8');
    else if (encoding === 'ucs2') dbuf.write(DT.ucs2, pos, 1, 'utf8');
    else throw 'unsupported encoding ' + encoding;

    var len = Buffer.byteLength(value, encoding);
    dbuf.write(value, pos + 1, len, encoding);

    if (pos + len + 1 > cur) cur = pos + len + 1;
    return len + 1; // signature
  }

  var writeStringArray = function (value, pos, encoding) {
    encoding = encoding || 'ucs2';
    if (encoding === 'utf8') dbuf.write(DT.utf8arr, pos, 1, 'utf8');
    else if (encoding === 'ucs2') dbuf.write(DT.ucs2arr, pos, 1, 'utf8');
    else throw 'unsupported encoding ' + encoding;

    var v = value.join('\0');
    var len = Buffer.byteLength(v, encoding);
    dbuf.write(v, pos + 1, len, encoding);
    if (pos + len + 1 > cur) cur = pos + len + 1;
    return len + 1;
  }

  var writeI32 = function (value, pos) {
    dbuf.write(DT.int32, pos, 1, 'utf8');
    dbuf.writeInt32BE(value, pos + 1);
    if (pos + 5 > cur) cur = pos + 5;
    return 5;
  }

  var writeUI8 = function (value, pos) {
    dbuf.write(DT.uint8, pos, 1, 'utf8');
    dbuf.writeUInt8(value, pos + 1);
    if (pos + 2 > cur) cur = pos + 2;
    return 2;
  }

  var writeBool = function (value, pos) {
    dbuf.write(DT.bool, pos, 1, 'utf8');
    dbuf.writeUInt8(Number(value), pos + 1);
    if (pos + 2 > cur) cur = pos + 2;
    return 2;
  }

  var writeBlob = function (value, pos) {
    dbuf.write(DT.blob, pos, 1, 'utf8');
    value.copy(dbuf, pos + 1);
    var written = value.length + 1;
    if (pos + written > cur) cur = pos + written;
    return written;
  }

  /* no signature */
  var writeFixedArray = function (value, pos, unitsize) {
    //console.log('v.len',value.length,items.length,unitsize);
    if (unitsize === 1) var func = dbuf.writeUInt8;
    else if (unitsize === 4) var func = dbuf.writeInt32BE;
    else throw 'unsupported integer size';

    for (var i = 0; i < value.length; i++) {
      func.apply(dbuf, [value[i], i * unitsize + pos])
    }
    var len = unitsize * value.length;
    if (pos + len > cur) cur = pos + len;
    return len;
  }

  var free = function () {
    return fs.write(handle, dbuf, 0, cur, 0, function () {
      fs.close(handle);
    });
  }

  this.writeI32 = writeI32;
  this.writeBool = writeBool;
  this.writeBlob = writeBlob;
  this.writeUI8 = writeUI8;
  this.writeString = writeString;
  this.writeSignature = writeSignature;
  this.writeOffset = writeOffset; //5 bytes offset
  this.writeStringArray = writeStringArray;
  this.writeFixedArray = writeFixedArray;
  this.free = free;

  handle = fs.openSync(path, 'w');
  return this;
}

module.exports = Create;
